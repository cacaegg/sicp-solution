;; Implementation of Queue
(define (make-queue)
 (let ((front '())
       (rear '()))
  (define (make-item val pre next) (list val pre next))
  (define get-val car)
  (define previous-item cadr)
  (define next-item caddr)
  (define (set-previous-item! item new-pre)
   (set-car! (cdr item) new-pre))
  (define (set-next-item! item new-next)
   (set-car! (cddr item) new-next))
  (define (set-front-ptr! item) (set! front item))
  (define (set-rear-ptr! item) (set! rear item))
  (define (empty-queue?) (null? front))
  (define (front-queue)
   (if (empty-queue?)
       (error 'front-queue "ERROR called with an empty queue" queue)
       (get-val front)))
  (define (rear-queue)
   (if (empty-queue?)
       (error 'rear-queue "ERROR called with empty queue" queue)
       (get-val rear)))
  (define (front-insert! val)
   (let ((new-item (make-item val '() '())))
    (cond ((empty-queue?)
           (set-front-ptr! new-item)
           (set-rear-ptr! new-item))
          (else
           (set-next-item! new-item front)
           (set-previous-item! front new-item)
           (set-front-ptr! new-item)))))
  (define (rear-insert! val)
   (let ((new-item (make-item val '() '())))
    (cond ((empty-queue?)
           (set-front-ptr! new-item)
           (set-rear-ptr! new-item))
          (else
           (set-next-item! rear new-item)
           (set-previous-item! new-item rear)
           (set-rear-ptr! new-item)))))
  (define (front-delete!)
   (cond ((empty-queue?)
          (error 'front-delete! "ERROR called with an empty queue"))
         (else
          (set-front-ptr! (next-item front))
          (if (not (empty-queue?))
              (set-previous-item! front '())))))

  (define (rear-delete!)
   (cond ((empty-queue?)
          (error 'rear-delete! "ERROR called with an empty queue"))
         (else
          (set-rear-ptr! (previous-item rear))
          (set-next-item! rear '()))))
  (define (print-queue)
   (define (traverse cur-item)
    (if (null? (next-item cur-item))
        (cons (get-val cur-item) '())
        (cons (get-val cur-item)
              (traverse (next-item cur-item)))))
   (if  (empty-queue?) 
        '()
        (traverse front)))
  (define (dispatch m)
   (cond ((eq? m 'front) front-queue)
         ((eq? m 'rear) rear-queue)
         ((eq? m 'front-insert!) front-insert!)
         ((eq? m 'rear-insert!) rear-insert!)
         ((eq? m 'front-delete!) front-delete!)
         ((eq? m 'rear-delete!) rear-delete!)
         ((eq? m 'print) 
          (lambda () (display (print-queue)) (newline)))
         ((eq? m 'empty?) empty-queue?)
         (else 
          (error 'dispatch "ERROR no such operation in queue" m))))
  dispatch))
(define (empty-queue? q) ((q 'empty?)))
(define (front-insert-queue! q val) 
 ((q 'front-insert!) val))
(define (rear-insert-queue! q val)
 ((q 'rear-insert!) val))
(define (front-delete-queue! q) ((q 'front-delete!)))
(define (rear-delete-queue! q) ((q 'rear-delete!)))
(define (front-queue q) ((q 'front)))
(define (rear-queue q) ((q 'rear)))
(define (print-queue q) ((q 'print)))

;; Implementation of Circuits
(define (make-wire)
 (define (call-each procs)
  (if (null? procs)
      'done
      (begin
       ((car procs))
       (call-each (cdr procs)))))
 (let ((signal-value 0) (action-procedures '()))
  (define (set-my-signal! new-value)
   (if (not (= signal-value new-value))
       (begin (set! signal-value new-value)
              (call-each action-procedures))
       'done))
  ; We need to do (proc) for initialization, or there will be no output
  ; if wire didn't change their input initial signal value from 0 to 1
  (define (accept-action-procedure! proc)
   (set! action-procedures (cons proc action-procedures))
   (proc)) 
  (define (dispatch m)
   (cond ((eq? m 'get-signal) signal-value)
         ((eq? m 'set-signal!) set-my-signal!)
         ((eq? m 'add-action!) accept-action-procedure!)
         (else (error 'make-wire "Unknown operation -- WIRE" m))))
  dispatch))
(define (add-action! wire action)
 ((wire 'add-action!) action))
(define (get-signal wire) (wire 'get-signal))
(define (set-signal! wire new-value)
 ((wire 'set-signal!) new-value))
(define (logical-not s)
 (cond ((= s 0) 1)
       ((= s 1) 0)
       (else (error 'logical-not "Invalid signal" s))))
(define (logical-and s1 s2)
 (cond ((and (= 1 s1) (= 1 s2)) 1)
       ((and (= 1 s1) (= 0 s2)) 0)
       ((and (= 0 s1) (= 1 s2)) 0)
       ((and (= 0 s1) (= 0 s2)) 0)
       (else (error 'logical-and "Invalid signal" s1 s2))))
(define (logical-or s1 s2)
 (cond ((and (= 1 s1) (= 1 s2)) 1)
       ((and (= 1 s1) (= 0 s2)) 1)
       ((and (= 0 s1) (= 1 s2)) 1)
       ((and (= 0 s1) (= 0 s2)) 0)
       (else (error 'logical-or "Invalid signal" s1 s2))))
(define (inverter input output)
 (define (invert-input)
  (let ((new-value (logical-not (get-signal input))))
   (after-delay inverter-delay
                (lambda ()
                 (set-signal! output new-value)))))
 (add-action! input invert-input)
 'ok)
(define (and-gate a1 a2 output)
 (define (and-action-procedure)
  (let ((new-value (logical-and (get-signal a1) (get-signal a2))))
   (after-delay and-gate-delay
    (lambda ()
     (set-signal! output new-value)))))
 (add-action! a1 and-action-procedure)
 (add-action! a2 and-action-procedure)
 'ok)
(define (or-gate a1 a2 output)
 (define (or-action-procedure)
  (let ((new-value
         (logical-or (get-signal a1) (get-signal a2))))
   (after-delay or-gate-delay
                (lambda ()
                 (set-signal! output new-value)))))
 (add-action! a1 or-action-procedure)
 (add-action! a2 or-action-procedure)
 'ok)
(define (half-adder a b s c)
 (let ((d (make-wire)) (e (make-wire)))
  (or-gate a b d)
  (and-gate a b c)
  (inverter c e)
  (and-gate d e s)
  'ok))
(define (full-adder a b c-in sum c-out)
 (let ((s (make-wire))
       (c1 (make-wire))
       (c2 (make-wire)))
  (half-adder b c-in s c1)
  (half-adder a s sum c2)
  (or-gate c1 c2 c-out)
  'ok))
(define (ripple-carry-adder an bn c-out sn)
 (define (add-iter an bn c-in sn)
  (if (null? (cdr an))
      (begin
       (full-adder (car an) (car bn) c-in (car s) c-out)
       'ok)
      (begin
       (make-wire carry-ab)
       (full-adder (car an) (car bn) c-in (car s) carry-ab)
       (add-iter (cdr an) (cdr bn) carry-ab (cdr sn)))))
 (add-iter an bn 0 sn))

;; Implementation of Time-based Agenda
(define (make-time-segment time queue)
 (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))
(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
 (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
 (set-cdr! agenda segments))
(define (first-segment agenda) (car (segments agenda)))
(define (rest-segments agenda) (cdr (segments agenda)))
(define (empty-agenda? agenda)
 (null? (segments agenda)))
(define (add-to-agenda! time action agenda)
 (define (belongs-before? segments)
  (or (null? segments)
      (< time (segment-time (car segments)))))
 (define (make-new-time-segment time action)
  (let ((q (make-queue)))
   (rear-insert-queue! q action)
   (make-time-segment time q)))
 (define (add-to-segments! segments)
  (if (= (segment-time (car segments)) time)
      ;(rear-insert-queue! (segment-queue (car segments)) ; First In, First Out
      (front-insert-queue! (segment-queue (car segments)) ; Last In, First Out
                          action)
      (let ((rest (cdr segments)))
       (if (belongs-before? rest)
           (set-cdr! 
            segments
            (cons (make-new-time-segment time action)
                  (cdr segments)))
           (add-to-segments! rest)))))
 (let ((segments (segments agenda)))
  (if (belongs-before? segments)
      (set-segments!
       agenda
       (cons (make-new-time-segment time action)
             segments))
      (add-to-segments! segments))))
(define (remove-first-agenda-item! agenda)
 (let ((q (segment-queue (first-segment agenda))))
  (front-delete-queue! q)
  (if (empty-queue? q)
      (set-segments! agenda (rest-segments agenda)))))
(define (first-agenda-item agenda)
 (if (empty-agenda? agenda)
     (error 'first-agenda-item "Agenda is empty")
     (let ((first-seg (first-segment agenda)))
      (set-current-time! agenda (segment-time first-seg))
      (front-queue (segment-queue first-seg)))))

;; Simulation propagate
(define (propagate)
 (if (empty-agenda? the-agenda)
     'done
     (let ((first-item (first-agenda-item the-agenda)))
      (first-item)
      (remove-first-agenda-item! the-agenda)
      (propagate))))
(define (probe name wire)
 (add-action! wire
              (lambda ()
               (newline)
               (display name)
               (display " time(")
               (display (current-time the-agenda))
               (display ") New-value = ")
               (display (get-signal wire)))))
(define (after-delay delay action)
 (add-to-agenda! (+ delay (current-time the-agenda))
                 action
                 the-agenda))

(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)

(define x (make-wire))
(define y (make-wire))
(define z (make-wire))

;(half-adder input-1 input-2 sum carry)
;(set-signal! input-1 1)
;(propagate)

(and-gate x y z)

(set-signal! x 0)
(set-signal! y 1)

(propagate)

(set-signal! x 1)
(set-signal! y 0)

(propagate)

(probe 'x x)
(probe 'y y)
(probe 'z z)
(newline)


; For each segment, procedure needs to execute as FIFO to properly propagate 
; the previous gate's result to next. 
; FIFO segment
;> (load "exec-3.32.ss")
;x time(6) New-value = 1
;y time(6) New-value = 0
;z time(6) New-value = 0
;
; LIFO segment
;> (load "exec-3.32.ss")
;x time(6) New-value = 1
;y time(6) New-value = 0
;z time(6) New-value = 1
