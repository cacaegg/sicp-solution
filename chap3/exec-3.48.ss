; Since the account is numbered, if our serialized implemnetation is gaining
; mutex from the lowest account number, then the next process who wishes to 
; gain the mutex will ecounter the lowest locked account first.
; This is why the lowest serialized account implementation can solve deadlock.
(import (chezscheme))
(define next-account-num 1)
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer))
        (identity next-account-num))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            ((eq? m 'identity) identity)
            (else (error 'make-account "Unknown request" m))))
    (set! next-account-num (1+ next-account-num))
    dispatch))

(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
(define (withdraw account amount)
  (let ((s (account 'serializer))
        (w (account 'withdraw)))
    ((s w) amount)))
(define (exchange account1 account2)
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
(define (serialized-exchange account1 account2)
  (let ((serializer1 (account 'serializer))
        (serializer2 (account 'serializer)))
    (if (> (account1 'identity) (account2 'identity))
        ((serializer1 (serializer2 exchange))
         account1
         account2)
        ((serializer2 (serializer1 exchange))
         account1
         account2))))
(define (make-mutex)
  (let ((cell (list #f)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire)))
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
(define (clear! cell)
  (set-car! cell #f))
(define (test-and-set! cell)
  (critical-section
    (if (car cell)
        #t
        (begin (set-car! cell #t)
               #f))))
(define peter-account (make-account-and-serializer 100))
(define paul-account (make-account-and-serializer 80))
(define paul (lambda () 
               (exchange peter-account paul-account)
               'paul))
(define peter (lambda () 
                (exchange paul-account peter-account)
                'peter))
;(paul)
;
(fork-thread paul)
(fork-thread peter)
(sleep (make-time 'time-duration 10 1))
(display (list 'peter (peter-account 'balance)))(newline)
(display (list 'paul (paul-account 'balance)))(newline)
