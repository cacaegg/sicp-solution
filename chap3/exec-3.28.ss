(define (make-table same-key?)
 (let ((local-table (list '*table*)))
  (define (tree-key tree) (car tree))
  (define (tree-val tree) (cadr tree))
  (define (left-branch tree) (caddr tree))
  (define (right-branch tree) (cadddr tree))
  (define (make-tree key val left right)
   (list key val left right))
  (define (set-key! tree new-key)
   (set-car! tree new-key))
  (define (set-val! tree new-val)
   (set-car! (cdr tree) new-val))
  (define (set-left-branch! tree new-tree)
   (set-car! (cddr tree) new-tree))
  (define (set-right-branch! tree new-tree)
   (set-car! (cdddr tree) new-tree))

  (define (lookup cur-tree key)
   (cond ((null? cur-tree) #f)
         ((same-key? key (tree-key cur-tree))
          (tree-val cur-tree))
         ((> key (tree-key cur-tree))
          (lookup (right-branch cur-tree) key))
         ((< key (tree-key cur-tree))
          (lookup (left-branch cur-tree) key))
         (else
          (error 'lookup "ERROR when do lookup" cur-tree key))))
  (define (insert! cur-tree key value)
   (cond ((same-key? key (tree-key cur-tree))
          (set-val! cur-tree value)
          'ok)
         ((> key (tree-key cur-tree))
          (if (null? (right-branch cur-tree))
              (set-right-branch! cur-tree
               (make-tree key value '() '()))
              (insert! (right-branch cur-tree) key value))
          'ok)
         (else
           (if (null? (left-branch cur-tree))
               (set-left-branch! cur-tree
                (make-tree key value '() '()))
               (insert! (left-branch cur-tree) key value))
           'ok)))
  (define (dispatch m)
   (cond ((eq? m 'lookup-proc) 
          (lambda (k) (lookup (cdr local-table) k)))
         ((eq? m 'insert-proc!) 
          (lambda (k v) 
           (if (null? (cdr local-table))
               (begin
                (set-cdr! local-table (make-tree k v '() '()))
                'ok)
               (insert! (cdr local-table) k v))))
         ((eq? m 'print) (lambda () (display local-table)(newline)))
         (else (error 'dispatch "Unknown operation -- TABLE" m))))
  dispatch))

(define wire-table (make-table eq?))
(define get-wire (wire-table 'lookup-proc))
(define put-wire (wire-table 'insert-proc!))
(define print-wire (wire-table 'print))

(define action-table (make-table eq?))
(define get-action (action-table 'lookup-proc))
(define put-action (action-table 'insert-proc!))
(define print-action (action-table 'print))

(define (get-signal wire) (get-wire wire))
(define (set-signal! wire new-value)
 (put-wire wire new-value))
(define (add-action! wire procedure)
 (let ((act (get-action wire)))
  (if (eq? act #f)
      (put-action wire (list procedure))
      (put-action wire (append act procedure)))))
(define make-wire
 (let ((cur-wire -1))
  (lambda () 
   (set! cur-wire (1+ cur-wire)) 
   (put-wire cur-wire 0)
   cur-wire)))

(define (or-gate a1 a2 output)
 (define (or-action-procedure)
  (let ((new-value
         (logical-or (get-signal a1) (get-signal a2))))
   (after-delay or-gate-delay
                (lambda ()
                 (set-signal! output new-value)))))
 (add-action! a1 or-action-procedure)
 (add-action! a2 or-action-procedure)
 'ok)
